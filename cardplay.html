<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">CARD PLAY</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: calc(100vh * 1920 / 1080);
            max-height: 100vh;
            aspect-ratio: 1920 / 1080;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 100%;
            aspect-ratio: 1920 / 1080;
            box-sizing: border-box;
            background-color: gray;
            pointer-events: auto;
        }

        .background-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 0;
        }

        .svg-overlay azok{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 1;
        }

        .svg-overlay ellipse {
            fill: none;
            stroke: none;
        }

        .numbers-container {
            position: absolute;
            z-index: 3;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .number-overlay {
            position: absolute;
            color: white;
            font-size: 1.3vw;
            font-weight: bold;
            text-align: center;
            transform: translate(-50%, -50%);
            z-index: 2;
            -webkit-text-stroke: 0.5px black;
            cursor: pointer;
            pointer-events: auto;
            padding: 4px 8px;
            border: 1px solid black;
            border-radius: 4px;
            opacity: 0.9;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .number-overlay.black {
            color: #ccc; /* Lighter text for Nooch's black */
            border: 1px solid #ccc;
        }

        .number-overlay.pending {
            border: 2px solid yellow;
            animation: flash 1s infinite;
        }

        .number-overlay.summary-highlight {
            border: 2px dashed cyan;
        }

        @keyframes flash {
            0% { border-color: yellow; }
            50% { border-color: orange; }
            100% { border-color: yellow; }
        }

        .number-overlay .tooltip {
            visibility: hidden;
            position: absolute;
            background-color: #333;
            color: white;
            padding: 5px;
            border-radius: 4px;
            font-size: 0.9em;
            z-index: 4;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
        }

        .number-overlay:hover .tooltip {
            visibility: visible;
        }

        .ui-panel {
            position: absolute;
            left: 75%;
            top: 1.8519%;
            width: 23.6979%;
            height: 96.3889%;
            background-color: #0000FF;
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .ui-panel p {
            margin: 10px 0;
            font-size: 1.4em;
            text-align: center;
        }

        .cards-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            display: none;
        }

        .card {
            width: 100px;
            height: 150px;
            background-size: cover;
            border: 2px solid white;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .card:hover {
            transform: scale(1.1);
        }

        .card.selected {
            border: 2px solid yellow;
        }

        .ui-panel button {
            margin: 10px 0;
            padding: 10px 20px;
            font-size: 1.2em;
            width: 80%;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
        }

        .ui-panel button:hover {
            background-color: #45a049;
        }

        .ui-panel button:disabled {
            background-color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .action-container {
            margin: 10px 0;
            width: 100%;
            text-align: center;
        }

        .pending-actions {
            margin: 10px 0;
            width: 100%;
            font-size: 1em;
            text-align: left;
        }

        #book-selection {
            margin: 10px 0;
            width: 100%;
            text-align: center;
        }

        #error-message {
            color: yellow;
            margin: 10px 0;
            font-size: 1em;
        }

        #summary-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222;
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 4;
            max-width: 400px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            font-size: 1.1em;
        }

        #summary-modal h2 {
            margin: 0 0 10px;
            text-align: center;
        }

        #summary-modal button {
            margin-top: 10px;
            padding: 10px;
            width: 100%;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #summary-modal button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="map-container" tabindex="0">
            <img class="background-map" src="stage.webp" alt="Stage Map" onerror="console.error('Failed to load stage.webp')">
            <img class="svg-overlay" src="stage.svg" alt="Stage Overlay" onerror="console.error('Failed to load stage.svg')">
            <div class="numbers-container"></div>
        </div>
        <div class="ui-panel">
            <p id="prompt">Loading...</p>
            <button id="decline-card-play">DECLINE CARD PLAY</button>
            <button id="view-cards">VIEW CARDS</button>
            <button id="play-book" disabled>PLAY BOOK</button>
            <button id="summary">SUMMARY</button>
            <div class="cards-container" id="cards-container"></div>
            <div class="action-container" id="action-container"></div>
            <div class="pending-actions" id="pending-actions"></div>
            <div id="book-selection"></div>
            <div id="error-message"></div>
            <button id="reset">RESET</button>
            <button id="confirm">CONFIRM</button>
        </div>
        <div id="summary-modal">
            <h2>Pending Actions Summary</h2>
            <div id="summary-content"></div>
            <button id="close-summary">Close</button>
        </div>
    </div>

    <script>
        const markerData = [
            { id: "alaska", x: 308.55679 - 222.0, y: 264.97107 },
            { id: "eastern_australia", x: 1595.4011 - 222.0, y: 746.38354 },
            { id: "western_australia", x: 1474.8748 - 222.0, y: 739.28302 },
            { id: "new_guinea", x: 1587.2722 - 222.0, y: 655.57501 },
            { id: "indonesia", x: 1446.3921 - 222.0, y: 650.74683 },
            { id: "siam", x: 1395.9755 - 222.0, y: 581.17511 },
            { id: "india", x: 1267.0215 - 222.0, y: 575.07788 },
            { id: "middle_east", x: 1129.2544 - 222.0, y: 588.84821 },
            { id: "japan", x: 1534.1827 - 222.0, y: 454.17877 },
            { id: "mongolia", x: 1433.4283 - 222.0, y: 427.65335 },
            { id: "china", x: 1360.6453 - 222.0, y: 493.22324 },
            { id: "afghanistan", x: 1218.2479 - 222.0, y: 468.07901 },
            { id: "irkutsk", x: 1441.7458 - 222.0, y: 338.06064 },
            { id: "kamchatka", x: 1589.5128 - 222.0, y: 309.51068 },
            { id: "yakutsk", x: 1477.2804 - 222.0, y: 209.76579 },
            { id: "siberia", x: 1340.1893 - 222.0, y: 262.83441 },
            { id: "ural", x: 1254.144 - 222.0, y: 324.73886 },
            { id: "madagascar", x: 1134.5453 - 222.0, y: 834.55969 },
            { id: "south_africa", x: 1024.1761 - 222.0, y: 828.63373 },
            { id: "congo", x: 1014.9386 - 222.0, y: 748.16016 },
            { id: "east_africa", x: 1069.7106 - 222.0, y: 680.7547 },
            { id: "egypt", x: 998.12262 - 222.0, y: 621.18164 },
            { id: "north_africa", x: 898.99554 - 222.0, y: 668.80823 },
            { id: "southern_europe", x: 1001.1808 - 222.0, y: 528.07111 },
            { id: "western_europe", x: 904.12915 - 222.0, y: 537.27295 },
            { id: "northern_europe", x: 975.70923 - 222.0, y: 477.00934 },
            { id: "great_britain", x: 894.8446 - 222.0, y: 451.23349 },
            { id: "ukraine", x: 1100.2609 - 222.0, y: 372.86716 },
            { id: "scandinavia", x: 992.61957 - 222.0, y: 349.13358 },
            { id: "iceland", x: 908.28015 - 222.0, y: 294.21164 },
            { id: "brazil", x: 601.57489 - 222.0, y: 731.95221 },
            { id: "argentina", x: 510.68674 - 222.0, y: 865.08704 },
            { id: "peru", x: 488.96512 - 222.0, y: 764.83447 },
            { id: "venezuela", x: 490.67105 - 222.0, y: 643.73474 },
            { id: "central_america", x: 449.37402 - 222.0, y: 576.0282 },
            { id: "eastern_united_states", x: 535.35651 - 222.0, y: 484.20441 },
            { id: "western_united_states", x: 411.80338 - 222.0, y: 456.33908 },
            { id: "quebec", x: 668.86243 - 222.0, y: 392.12085 },
            { id: "ontario", x: 544.64899 - 222.0, y: 368.582 },
            { id: "alberta", x: 417.74677 - 222.0, y: 364.97565 },
            { id: "greenland", x: 806.80243 - 222.0, y: 186.89986 },
            { id: "northwest_territory", x: 424.72784 - 222.0, y: 280.13437 }
        ];

        const colorMap = {
            "Blue": "#0000FF",
            "Pink": "#ff69b4",
            "Black": "#000000",
            "Red": "#FF0000"
        };

        const cardTypes = {
            "afghanistan": "infantry",
            "alaska": "artillery",
            "alberta": "artillery",
            "argentina": "infantry",
            "brazil": "infantry",
            "central_america": "infantry",
            "china": "artillery",
            "congo": "artillery",
            "east_africa": "infantry",
            "eastern_australia": "cavalry",
            "eastern_united_states": "artillery",
            "egypt": "cavalry",
            "great_britain": "infantry",
            "greenland": "cavalry",
            "iceland": "cavalry",
            "india": "cavalry",
            "indonesia": "infantry",
            "irkutsk": "artillery",
            "japan": "cavalry",
            "kamchatka": "artillery",
            "madagascar": "cavalry",
            "middle_east": "artillery",
            "mongolia": "cavalry",
            "new_guinea": "cavalry",
            "northwest_territory": "cavalry",
            "north_africa": "infantry",
            "northern_europe": "cavalry",
            "ontario": "artillery",
            "peru": "cavalry",
            "quebec": "artillery",
            "scandinavia": "infantry",
            "siam": "cavalry",
            "siberia": "infantry",
            "south_africa": "artillery",
            "southern_europe": "infantry",
            "ukraine": "infantry",
            "ural": "infantry",
            "venezuela": "cavalry",
            "western_australia": "artillery",
            "western_europe": "infantry",
            "western_united_states": "artillery",
            "yakutsk": "artillery",
            "wildcard1": null,
            "wildcard2": null
        };

        let players = [];
        let currentPlayerIndex = 0;
        let gameState = {
            territories: {},
            banks: {},
            cards: {},
            turnOrder: [],
            continentBonuses: {
                "north_america": 5,
                "south_america": 2,
                "europe": 5,
                "africa": 3,
                "asia": 7,
                "australia": 2
            },
            round: 1,
            discardedCards: []
        };
        let selectedCard = null;
        let pendingActions = [];
        let isSelectingSource = false;
        let isSelectingTarget = false;
        let showCards = false;
        let bookSelection = [];
        let assignedWildcardTypes = {};
        let isSummaryOpen = false;

        const prompt = document.getElementById("prompt");
        const viewCardsBtn = document.getElementById("view-cards");
        const playBookBtn = document.getElementById("play-book");
        const cardsContainer = document.getElementById("cards-container");
        const actionContainer = document.getElementById("action-container");
        const pendingActionsDiv = document.getElementById("pending-actions");
        const bookSelectionDiv = document.getElementById("book-selection");
        const errorMessage = document.getElementById("error-message");
        const resetBtn = document.getElementById("reset");
        const confirmBtn = document.getElementById("confirm");
        const declineCardPlayBtn = document.getElementById("decline-card-play");
        const summaryBtn = document.getElementById("summary");
        const summaryModal = document.getElementById("summary-modal");
        const summaryContent = document.getElementById("summary-content");
        const closeSummaryBtn = document.getElementById("close-summary");
        const pageTitle = document.getElementById("page-title");

        function checkAssets() {
            const assets = ["stage.webp", "stage.svg", "cards/alaska.png", "cards/wildcard.png"];
            assets.forEach(asset => {
                const img = new Image();
                img.src = asset;
                img.onload = () => console.log(`Asset loaded: ${asset}`);
                img.onerror = () => {
                    console.error(`Failed to load asset: ${asset}`);
                    errorMessage.innerText = `Error: Missing asset ${asset}.`;
                };
            });
        }

        function initializeGame() {
            console.log("Initializing cardplay.html with fresh random data");
            checkAssets();

            try {
                localStorage.removeItem("gameState");
                localStorage.removeItem("players");
                console.log("Cleared localStorage");
            } catch (e) {
                console.error("Failed to clear localStorage:", e);
                errorMessage.innerText = "Error: Could not reset game state.";
            }

            const playerData = [
                { name: "Guido", color: "Blue" },
                { name: "Karl", color: "Pink" },
                { name: "Nooch", color: "Black" },
                { name: "Mickey", color: "Red" }
            ];
            const playerCount = Math.floor(Math.random() * 3) + 2; // 2â€“4 players
            players = [];
            const shuffledIndices = Array.from({ length: 4 }, (_, i) => i).sort(() => Math.random() - 0.5);
            for (let i = 0; i < playerCount; i++) {
                players.push(playerData[shuffledIndices[i]]);
            }
            currentPlayerIndex = Math.floor(Math.random() * playerCount);
            const randomPlayer = players[currentPlayerIndex];
            console.log(`Selected player: ${randomPlayer.name}, color: ${randomPlayer.color}, index: ${currentPlayerIndex}, players:`, players.map(p => `${p.name} (${p.color})`));

            gameState = {
                territories: {},
                banks: { [randomPlayer.name]: 0 },
                cards: { [randomPlayer.name]: [] },
                turnOrder: players,
                continentBonuses: {
                    "north_america": 5,
                    "south_america": 2,
                    "europe": 5,
                    "africa": 3,
                    "asia": 7,
                    "australia": 2
                },
                round: 1,
                discardedCards: []
            };

            markerData.forEach(m => {
                const owner = players[Math.floor(Math.random() * players.length)].name;
                gameState.territories[m.id] = {
                    owner,
                    armies: Math.floor(Math.random() * 10) + 1
                };
            });
            console.log("Randomized territories:", Object.entries(gameState.territories).map(([id, t]) => `${id}: ${t.owner}, ${t.armies}`));

            const availableCards = [...markerData.map(m => ({ id: m.id, type: cardTypes[m.id] })), 
                                  { id: "wildcard1", type: null }, { id: "wildcard2", type: null }];
            const cardCount = Math.floor(Math.random() * 6);
            const selectedCards = [];
            for (let i = 0; i < cardCount; i++) {
                if (availableCards.length === 0) break;
                const cardIndex = Math.floor(Math.random() * availableCards.length);
                selectedCards.push(availableCards.splice(cardIndex, 1)[0]);
            }
            gameState.cards[randomPlayer.name] = selectedCards;
            console.log(`Assigned ${cardCount} cards to ${randomPlayer.name}:`, selectedCards.map(c => c.id));

            renderMap();
            updateUI();
            document.querySelector(".map-container").focus();
        }

        function renderMap() {
            const numbersContainer = document.querySelector(".numbers-container");
            const mapWidth = 1920;
            const mapHeight = 1080;

            const xCoords = markerData.map(m => m.x);
            const yCoords = markerData.map(m => m.y);
            const minX = Math.min(...xCoords);
            const maxX = Math.max(...xCoords);
            const minY = Math.min(...yCoords);
            const maxY = Math.max(...yCoords);

            const scaledLeft = (minX / mapWidth) * 100;
            const scaledTop = (minY / mapHeight) * 100;
            const scaledWidth = ((maxX - minX) / mapWidth) * 100;
            const scaledHeight = ((maxY - minY) / mapHeight) * 100;

            numbersContainer.style.left = `${scaledLeft}%`;
            numbersContainer.style.top = `${scaledTop}%`;
            numbersContainer.style.width = `${scaledWidth}%`;
            numbersContainer.style.height = `${scaledHeight}%`;

            numbersContainer.innerHTML = "";
            markerData.forEach(marker => {
                const territory = gameState.territories[marker.id];
                if (!territory) {
                    console.error(`Territory ${marker.id} not initialized.`);
                    errorMessage.innerText = `Error: Territory ${marker.id} not found.`;
                    return;
                }
                let armies = territory.armies;
                let owner = territory.owner;
                let isPending = false;
                let tooltipText = "";

                pendingActions.forEach(action => {
                    if (action.territory === marker.id) {
                        isPending = true;
                        if (action.type === "add_armies_to_territory") {
                            armies += action.amount;
                            tooltipText = `+${action.amount} armies pending`;
                        } else if (action.type === "remove_armies" && !action.declined) {
                            armies = Math.max(1, armies - action.amount);
                            tooltipText = `-${action.amount} armies pending`;
                        } else if (action.type === "acquire_territory") {
                            owner = gameState.turnOrder[currentPlayerIndex].name;
                            armies = 1;
                            tooltipText = `Acquired by ${owner}`;
                        }
                    } else if (action.type === "aerial_attack" && action.target === marker.id) {
                        isPending = true;
                        armies = Math.max(1, armies - 2);
                        tooltipText = "-2 armies (aerial attack)";
                    }
                });

                const armiesText = armies.toString().padStart(3, "0");
                const numberDiv = document.createElement("div");
                numberDiv.className = "number-overlay";
                if (isPending) numberDiv.classList.add("pending");
                if (isSummaryOpen && pendingActions.some(a => a.territory === marker.id || (a.type === "aerial_attack" && a.target === marker.id))) {
                    numberDiv.classList.add("summary-highlight");
                }
                const player = players.find(p => p.name === owner);
                if (player && player.color === "Black") {
                    numberDiv.classList.add("black");
                }
                numberDiv.innerText = armiesText;
                numberDiv.dataset.id = marker.id;

                if (player) {
                    const cssColor = colorMap[player.color] || "#FFFFFF";
                    numberDiv.style.backgroundColor = cssColor;
                }

                if (tooltipText) {
                    const tooltip = document.createElement("span");
                    tooltip.className = "tooltip";
                    tooltip.innerText = tooltipText;
                    numberDiv.appendChild(tooltip);
                }

                const scaledX = ((marker.x - minX) / (maxX - minX)) * 100;
                const scaledY = ((marker.y - minY) / (maxY - minY)) * 100;
                numberDiv.style.left = `${scaledX}%`;
                numberDiv.style.top = `${scaledY}%`;

                numberDiv.addEventListener("click", () => {
                    handleTerritoryClick(marker.id);
                });

                numbersContainer.appendChild(numberDiv);
            });
            console.log(`Rendered ${markerData.length} territory numbers`);
        }

        function updateUI() {
            if (currentPlayerIndex >= gameState.turnOrder.length || !gameState.turnOrder[currentPlayerIndex]) {
                console.error(`Invalid currentPlayerIndex: ${currentPlayerIndex}, turnOrder:`, gameState.turnOrder);
                prompt.innerText = "Error: Invalid player setup. Please reload.";
                errorMessage.innerText = "Failed to load player data. Check console for details.";
                return;
            }

            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            pageTitle.innerText = `${currentPlayer.name} CARD PLAY`;
            prompt.innerText = showCards ? 
                `${currentPlayer.name}, select a card or click HIDE CARDS.` : 
                `${currentPlayer.name}, play your cards or click CONFIRM to continue.`;
            viewCardsBtn.innerText = showCards ? "HIDE CARDS" : "VIEW CARDS";
            cardsContainer.style.display = showCards ? "flex" : "none";
            const playerCards = gameState.cards[currentPlayer.name] || [];
            playBookBtn.disabled = playerCards.length < 3;
            actionContainer.innerHTML = "";
            bookSelectionDiv.innerHTML = "";
            if (!errorMessage.innerText) errorMessage.innerText = "";
            selectedCard = null;
            isSelectingSource = false;
            isSelectingTarget = false;
            renderCards();
            renderPendingActions();
            console.log(`UI updated for ${currentPlayer.name}, cards: ${playerCards.length}`);
        }

        function renderCards() {
            cardsContainer.innerHTML = "";
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            const playerCards = gameState.cards[currentPlayer.name] || [];
            if (playerCards.length === 0 && showCards) {
                prompt.innerText = "No cards available to play.";
            }
            playerCards.forEach((card, index) => {
                const cardDiv = document.createElement("div");
                cardDiv.className = "card";
                cardDiv.style.backgroundImage = `url('cards/${card.id.startsWith("wildcard") ? "wildcard" : card.id}.png')`;
                cardDiv.dataset.index = index;
                if (selectedCard && selectedCard.index === index) {
                    cardDiv.classList.add("selected");
                }
                cardDiv.addEventListener("click", () => selectCard(index));
                cardsContainer.appendChild(cardDiv);
            });
            console.log(`Rendered ${playerCards.length} cards for ${currentPlayer.name}`);
        }

        function selectCard(index) {
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            const playerCards = gameState.cards[currentPlayer.name] || [];
            if (playerCards.length === 0) {
                prompt.innerText = "No cards to play.";
                console.log("No cards available to select");
                return;
            }
            if (playerCards.length <= index) {
                console.error(`Invalid card index: ${index}`);
                errorMessage.innerText = "Error: Invalid card selection.";
                return;
            }
            selectedCard = { index, card: playerCards[index] };
            prompt.innerText = `Selected ${selectedCard.card.id.startsWith("wildcard") ? "Wildcard" : selectedCard.card.id}. Choose an action.`;
            renderCardActions();
            renderCards();
            console.log(`Selected card: ${selectedCard.card.id} at index ${index}`);
        }

        function hasPendingActionForTerritory(territoryId) {
            return pendingActions.some(a => a.territory === territoryId || (a.type === "aerial_attack" && a.target === territoryId));
        }

        function renderCardActions() {
            actionContainer.innerHTML = "";
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            const card = selectedCard.card;
            const territory = gameState.territories[card.id];

            if (hasPendingActionForTerritory(card.id)) {
                prompt.innerText = `Territory ${card.id} already has a pending action.`;
                errorMessage.innerText = "Please undo the existing action or select another card.";
                return;
            }

            if (card.id.startsWith("wildcard")) {
                const playAsTerritoryBtn = document.createElement("button");
                playAsTerritoryBtn.innerText = "Add 2 Armies to Owned Territory";
                playAsTerritoryBtn.addEventListener("click", () => {
                    isSelectingSource = true;
                    prompt.innerText = "Click an owned territory to add 2 armies.";
                    console.log("Selecting owned territory for wildcard");
                });
                actionContainer.appendChild(playAsTerritoryBtn);

                const aerialAttackBtn = document.createElement("button");
                aerialAttackBtn.innerText = "Launch Aerial Attack";
                aerialAttackBtn.addEventListener("click", () => {
                    isSelectingSource = true;
                    prompt.innerText = "Click an owned territory to attack from.";
                    console.log("Initiated aerial attack, selecting source");
                });
                actionContainer.appendChild(aerialAttackBtn);
            } else if (territory && territory.owner === currentPlayer.name) {
                const addArmiesBtn = document.createElement("button");
                addArmiesBtn.innerText = `Add 2 Armies to ${card.id}`;
                addArmiesBtn.addEventListener("click", () => {
                    pendingActions.push({
                        type: "add_armies_to_territory",
                        territory: card.id,
                        amount: 2,
                        cardIndex: selectedCard.index
                    });
                    renderMap();
                    updateUI();
                    console.log(`Added action: Add 2 armies to ${card.id}`);
                });
                actionContainer.appendChild(addArmiesBtn);
            } else if (!card.id.startsWith("wildcard")) {
                const targetTerritory = gameState.territories[card.id];
                if (targetTerritory.armies <= 2) {
                    const acquireBtn = document.createElement("button");
                    acquireBtn.innerText = `Acquire ${card.id}`;
                    acquireBtn.addEventListener("click", () => {
                        pendingActions.push({
                            type: "acquire_territory",
                            territory: card.id,
                            cardIndex: selectedCard.index,
                            previousOwner: targetTerritory.owner
                        });
                        renderMap();
                        updateUI();
                        console.log(`Added action: Acquire ${card.id}`);
                    });
                    actionContainer.appendChild(acquireBtn);
                } else {
                    const removeArmiesBtn = document.createElement("button");
                    removeArmiesBtn.innerText = `Remove 2 Armies from ${card.id}`;
                    removeArmiesBtn.addEventListener("click", () => {
                        pendingActions.push({
                            type: "remove_armies",
                            territory: card.id,
                            amount: 2,
                            cardIndex: selectedCard.index,
                            declined: false
                        });
                        renderMap();
                        updateUI();
                        console.log(`Added action: Remove 2 armies from ${card.id}`);
                    });
                    actionContainer.appendChild(removeArmiesBtn);

                    const declineRemovalBtn = document.createElement("button");
                    declineRemovalBtn.innerText = "Decline Removal";
                    declineRemovalBtn.addEventListener("click", () => {
                        prompt.innerText = `Declined removal from ${card.id}. Select another action or keep/discard card.`;
                        updateUI();
                        console.log(`Declined removal from ${card.id}`);
                    });
                    actionContainer.appendChild(declineRemovalBtn);
                }
            }

            const discardBtn = document.createElement("button");
            discardBtn.innerText = "Discard Card";
            discardBtn.addEventListener("click", () => {
                gameState.discardedCards = gameState.discardedCards || [];
                gameState.discardedCards.push(card);
                gameState.cards[currentPlayer.name].splice(selectedCard.index, 1);
                selectedCard = null;
                updateUI();
                console.log(`Discarded card: ${card.id}`);
            });
            actionContainer.appendChild(discardBtn);

            const keepBtn = document.createElement("button");
            keepBtn.innerText = "Keep Card";
            keepBtn.addEventListener("click", () => {
                selectedCard = null;
                updateUI();
                console.log("Kept card, cleared selection");
            });
            actionContainer.appendChild(keepBtn);
        }

        function handleTerritoryClick(id) {
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            if (!selectedCard || (!isSelectingSource && !isSelectingTarget)) return;

            if (isSelectingSource) {
                if (gameState.territories[id].owner !== currentPlayer.name) {
                    prompt.innerText = `You do not own ${id}. Click an owned territory.`;
                    console.log(`Invalid source: ${id} not owned by ${currentPlayer.name}`);
                    return;
                }
                if (hasPendingActionForTerritory(id)) {
                    prompt.innerText = `Territory ${id} already has a pending action.`;
                    errorMessage.innerText = "Please undo the existing action or select another territory.";
                    return;
                }
                if (selectedCard.card.id.startsWith("wildcard")) {
                    pendingActions.push({
                        type: "add_armies_to_territory",
                        territory: id,
                        amount: 2,
                        cardIndex: selectedCard.index
                    });
                    isSelectingSource = false;
                    renderMap();
                    updateUI();
                    console.log(`Added action: Add 2 armies to ${id} (wildcard)`);
                } else {
                    pendingActions.push({
                        type: "aerial_attack",
                        source: id,
                        cardIndex: selectedCard.index
                    });
                    isSelectingSource = false;
                    isSelectingTarget = true;
                    prompt.innerText = "Click a territory to attack.";
                    console.log(`Selected source territory: ${id} for aerial attack`);
                }
            } else if (isSelectingTarget) {
                if (hasPendingActionForTerritory(id)) {
                    prompt.innerText = `Territory ${id} already has a pending action.`;
                    errorMessage.innerText = "Please undo the existing action or select another territory.";
                    return;
                }
                pendingActions[pendingActions.length - 1].target = id;
                isSelectingTarget = false;
                renderMap();
                updateUI();
                console.log(`Selected target territory: ${id} for aerial attack`);
            }
        }

        function renderPendingActions() {
            pendingActionsDiv.innerHTML = "<strong>Pending Actions:</strong><br>";
            if (pendingActions.length === 0) {
                pendingActionsDiv.innerHTML += "No pending actions.";
            }
            pendingActions.forEach((action, index) => {
                let text = "";
                if (action.type === "add_armies_to_territory") {
                    text = `Add ${action.amount} armies to ${action.territory}`;
                } else if (action.type === "remove_armies") {
                    text = action.declined ? `Declined removal from ${action.territory}` : `Remove ${action.amount} armies from ${action.territory}`;
                } else if (action.type === "acquire_territory") {
                    text = `Acquire ${action.territory} with 1 army`;
                } else if (action.type === "aerial_attack") {
                    text = `Aerial attack from ${action.source} to ${action.target}`;
                }
                pendingActionsDiv.innerHTML += `${text} <button onclick="removePendingAction(${index})">Undo</button><br>`;
            });
            console.log("Pending actions rendered:", pendingActions);
        }

        function removePendingAction(index) {
            pendingActions.splice(index, 1);
            renderMap();
            updateUI();
            console.log(`Removed pending action at index ${index}`);
        }

        function showSummary() {
            isSummaryOpen = true;
            summaryContent.innerHTML = "<strong>Pending Actions:</strong><br>";
            if (pendingActions.length === 0) {
                summaryContent.innerHTML += "No pending actions.";
            } else {
                pendingActions.forEach(action => {
                    if (action.type === "add_armies_to_territory") {
                        summaryContent.innerHTML += `Add ${action.amount} armies to ${action.territory}<br>`;
                    } else if (action.type === "remove_armies") {
                        summaryContent.innerHTML += action.declined ? 
                            `Declined removal from ${action.territory}<br>` : 
                            `Remove ${action.amount} armies from ${action.territory}<br>`;
                    } else if (action.type === "acquire_territory") {
                        summaryContent.innerHTML += `Acquire ${action.territory} with 1 army<br>`;
                    } else if (action.type === "aerial_attack") {
                        summaryContent.innerHTML += `Aerial attack from ${action.source} to ${action.target}<br>`;
                    }
                });
            }
            summaryModal.style.display = "block";
            renderMap();
            console.log("Displayed summary modal");
        }

        function closeSummary() {
            isSummaryOpen = false;
            summaryModal.style.display = "none";
            renderMap();
            console.log("Closed summary modal");
        }

        function startBookPlay() {
            bookSelection = [];
            assignedWildcardTypes = {};
            bookSelectionDiv.innerHTML = "<strong>Select 3 Cards for Book:</strong><br>";
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            const playerCards = gameState.cards[currentPlayer.name] || [];
            playerCards.forEach((card, index) => {
                const cardElement = document.createElement("div");
                cardElement.innerText = card.id.startsWith("wildcard") ? "Wildcard" : `${card.id} (${card.type})`;
                cardElement.style.padding = "5px";
                cardElement.style.cursor = "pointer";
                cardElement.addEventListener("click", () => {
                    if (bookSelection.some(c => c.index === index)) {
                        bookSelection = bookSelection.filter(c => c.index !== index);
                        delete assignedWildcardTypes[card.id];
                    } else if (bookSelection.length < 3) {
                        bookSelection.push({ card, index });
                        if (card.id.startsWith("wildcard")) {
                            promptWildcardType(card, index);
                        }
                    }
                    renderBookSelection();
                    console.log(`Book selection updated:`, bookSelection.map(c => c.card.id));
                });
                bookSelectionDiv.appendChild(cardElement);
            });
            renderBookSelection();
        }

        function promptWildcardType(card, index) {
            const typeSelection = document.createElement("select");
            ["infantry", "cavalry", "artillery"].forEach(type => {
                const option = document.createElement("option");
                option.value = type;
                option.innerText = type.charAt(0).toUpperCase() + type.slice(1);
                typeSelection.appendChild(option);
            });
            typeSelection.addEventListener("change", () => {
                assignedWildcardTypes[card.id] = typeSelection.value;
                console.log(`Assigned wildcard type: ${card.id} = ${typeSelection.value}`);
            });
            bookSelectionDiv.appendChild(typeSelection);
        }

        function renderBookSelection() {
            const selectedList = document.createElement("div");
            selectedList.innerText = `Selected: ${bookSelection.map(c => c.card.id.startsWith("wildcard") ? "Wildcard" : c.card.id).join(", ")}`;
            bookSelectionDiv.appendChild(selectedList);

            errorMessage.innerText = "";
            if (bookSelection.length === 3) {
                const confirmButton = document.createElement("button");
                confirmButton.innerText = "Confirm Book";
                confirmButton.addEventListener("click", confirmBook);
                bookSelectionDiv.appendChild(confirmButton);

                if (!isValidBook(bookSelection)) {
                    errorMessage.innerText = "Invalid book: Must be three of a kind or one of each type.";
                    confirmButton.disabled = true;
                    console.log("Invalid book detected");
                }
            }
        }

        function isValidBook(cards) {
            const types = cards.map(c => assignedWildcardTypes[c.card.id] || c.card.type);
            const nonNullTypes = types.filter(t => t !== null);
            const uniqueTypes = [...new Set(nonNullTypes)];
            const isValid = (uniqueTypes.length === 1 && nonNullTypes.length === 3) || 
                           (uniqueTypes.length === 3 && nonNullTypes.length === 3);
            console.log(`Book validation: types=${types}, valid=${isValid}`);
            return isValid;
        }

        function confirmBook() {
            if (!isValidBook(bookSelection)) return;

            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            bookSelectionDiv.innerHTML = "<strong>Choose Actions for Book Cards:</strong><br>";
            bookSelection.forEach(({ card, index }) => {
                const cardElement = document.createElement("div");
                cardElement.innerText = card.id.startsWith("wildcard") ? "Wildcard" : card.id;
                const territory = gameState.territories[card.id];

                const actionButton = document.createElement("button");
                const isOwned = territory && territory.owner === currentPlayer.name;
                let actionLabel;
                if (card.id.startsWith("wildcard")) {
                    actionLabel = "Add 2 Armies to Owned Territory";
                } else if (isOwned) {
                    actionLabel = `Add 2 Armies to ${card.id}`;
                } else if (territory && territory.armies <= 2) {
                    actionLabel = `Acquire ${card.id}`;
                } else {
                    actionLabel = `Remove 2 Armies from ${card.id}`;
                }
                actionButton.innerText = actionLabel;
                actionButton.addEventListener("click", () => {
                    if (hasPendingActionForTerritory(card.id) && !card.id.startsWith("wildcard")) {
                        prompt.innerText = `Territory ${card.id} already has a pending action.`;
                        errorMessage.innerText = "Please undo the existing action.";
                        return;
                    }
                    if (actionLabel.includes("Add 2 Armies to Owned Territory")) {
                        isSelectingSource = true;
                        prompt.innerText = "Click an owned territory to add 2 armies.";
                        console.log(`Book action: Selecting territory for wildcard ${card.id}`);
                    } else if (actionLabel.includes("Add 2 Armies")) {
                        pendingActions.push({
                            type: "add_armies_to_territory",
                            territory: card.id,
                            amount: 2,
                            cardIndex: index
                        });
                        console.log(`Book action: Add 2 armies to ${card.id}`);
                    } else if (actionLabel.includes("Acquire")) {
                        pendingActions.push({
                            type: "acquire_territory",
                            territory: card.id,
                            cardIndex: index,
                            previousOwner: territory.owner
                        });
                        console.log(`Book action: Acquire ${card.id}`);
                    } else {
                        pendingActions.push({
                            type: "remove_armies",
                            territory: card.id,
                            amount: 2,
                            cardIndex: index,
                            declined: false
                        });
                        console.log(`Book action: Remove 2 armies from ${card.id}`);
                    }
                    renderMap();
                    removeCardFromBook(index);
                });

                if (!card.id.startsWith("wildcard") && !isOwned && territory && territory.armies > 2) {
                    const declineButton = document.createElement("button");
                    declineButton.innerText = "Decline Removal";
                    declineButton.addEventListener("click", () => {
                        prompt.innerText = `Declined removal from ${card.id}.`;
                        removeCardFromBook(index);
                        console.log(`Book action: Declined removal from ${card.id}`);
                    });
                    cardElement.appendChild(declineButton);
                }

                const discardButton = document.createElement("button");
                discardButton.innerText = "Discard Card";
                discardButton.addEventListener("click", () => {
                    gameState.discardedCards = gameState.discardedCards || [];
                    gameState.discardedCards.push(card);
                    removeCardFromBook(index);
                    console.log(`Book action: Discarded ${card.id}`);
                });

                const keepButton = document.createElement("button");
                keepButton.innerText = "Keep Card";
                keepButton.addEventListener("click", () => {
                    removeCardFromBook(index);
                    console.log(`Book action: Kept ${card.id}`);
                });

                cardElement.appendChild(actionButton);
                cardElement.appendChild(discardButton);
                cardElement.appendChild(keepButton);
                bookSelectionDiv.appendChild(cardElement);
            });

            renderMap();
            updateUI();
        }

        function removeCardFromBook(index) {
            bookSelection = bookSelection.filter(c => c.index !== index);
            if (bookSelection.length === 0) {
                bookSelectionDiv.innerHTML = "";
            }
            updateUI();
            console.log(`Removed card from book selection at index ${index}`);
        }

        function applyPendingActions() {
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            const playerCards = gameState.cards[currentPlayer.name];
            const usedCardIndices = new Set();

            pendingActions.forEach(action => {
                if (usedCardIndices.has(action.cardIndex)) {
                    console.warn(`Duplicate card index ${action.cardIndex} ignored`);
                    return;
                }
                usedCardIndices.add(action.cardIndex);

                if (action.type === "add_armies_to_territory") {
                    gameState.territories[action.territory].armies += action.amount;
                } else if (action.type === "remove_armies" && !action.declined) {
                    const territory = gameState.territories[action.territory];
                    territory.armies = Math.max(1, territory.armies - action.amount);
                } else if (action.type === "acquire_territory") {
                    const territory = gameState.territories[action.territory];
                    territory.owner = currentPlayer.name;
                    territory.armies = 1;
                } else if (action.type === "aerial_attack") {
                    const targetTerritory = gameState.territories[action.target];
                    targetTerritory.armies = Math.max(1, targetTerritory.armies - 2);
                }
            });

            gameState.cards[currentPlayer.name] = playerCards.filter((_, index) => !usedCardIndices.has(index));
            console.log(`Applied ${usedCardIndices.size} actions, remaining cards: ${gameState.cards[currentPlayer.name].length}`);
        }

        declineCardPlayBtn.addEventListener("click", () => {
            pendingActions = [];
            selectedCard = null;
            isSelectingSource = false;
            isSelectingTarget = false;
            bookSelection = [];
            assignedWildcardTypes = {};
            bookSelectionDiv.innerHTML = "";
            errorMessage.innerText = "";
            prompt.innerText = "Card play declined. Click CONFIRM to continue.";
            renderMap();
            updateUI();
            console.log("Declined card play");
        });

        viewCardsBtn.addEventListener("click", () => {
            showCards = !showCards;
            updateUI();
            console.log(`Toggled card visibility: ${showCards}`);
        });

        playBookBtn.addEventListener("click", startBookPlay);

        resetBtn.addEventListener("click", () => {
            pendingActions = [];
            selectedCard = null;
            isSelectingSource = false;
            isSelectingTarget = false;
            bookSelection = [];
            assignedWildcardTypes = {};
            bookSelectionDiv.innerHTML = "";
            errorMessage.innerText = "";
            renderMap();
            updateUI();
            console.log("Reset card play state");
        });

        summaryBtn.addEventListener("click", showSummary);
        closeSummaryBtn.addEventListener("click", closeSummary);

        confirmBtn.addEventListener("click", () => {
            const currentPlayer = gameState.turnOrder[currentPlayerIndex];
            if (pendingActions.length > 0) {
                applyPendingActions();
                console.log(`Applied ${pendingActions.length} card play actions for ${currentPlayer.name}`);
            } else {
                console.log(`No card play actions applied for ${currentPlayer.name}`);
            }
            try {
                localStorage.setItem("gameState", JSON.stringify(gameState));
                localStorage.setItem("players", JSON.stringify(players));
                console.log("Saved game state to localStorage");
            } catch (e) {
                console.error("Failed to save to localStorage:", e);
                errorMessage.innerText = "Error: Could not save game state.";
            }
            console.log("Redirecting to deploy_armies.html");
            window.location.href = "deploy_armies.html";
        });

        window.addEventListener("beforeunload", () => {
            try {
                localStorage.removeItem("gameState");
                localStorage.removeItem("players");
            } catch (e) {
                console.error("Failed to clear localStorage on unload:", e);
            }
        });

        window.onload = initializeGame;
    </script>
</body>
</html>